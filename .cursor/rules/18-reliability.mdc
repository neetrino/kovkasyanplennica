---
description: ’Ä’∏÷Ç’Ω’°’¨’´’∏÷Ç’©’µ’°’∂ ’Ø’°’∂’∏’∂’∂’•÷Ä÷â Timeouts, retries, graceful shutdown, fault tolerance÷â
globs: ["**/*.ts", "**/api/**", "**/server/**"]
alwaysApply: false
---

# ’Ä’à’í’ç‘±‘º‘ª’à’í‘π’Ö‘±’Ü ‘ø‘±’Ü’à’Ü’Ü‘µ’ê

> ‘±’¥’•’∂ ’´’∂’π ’Ø’∏’ø÷Ä’æ’∏÷Ç’¥ ’ß÷â ’Ä’°÷Ä÷Å’® ’∂÷Ä’°’∂’∏÷Ç’¥ ’ß, ’©’• ’´’∂’π’∫’•’Ω ’ß ’∞’°’¥’°’Ø’°÷Ä’£’® ’°÷Ä’±’°’£’°’∂÷Ñ’∏÷Ç’¥÷â

---

## üéØ ’Ä‘ª’Ñ’Ü‘±‘ø‘±’Ü ’ç‘ø‘∂‘≤’à’í’Ü’î’Ü‘µ’ê

1. **Fail Fast** ‚Äî ’°’∂’æ’•÷Ä’ª ’¥’´ ’Ω’∫’°’Ω’´, ’§’´÷Ä timeout-’•÷Ä
2. **Graceful Degradation** ‚Äî ’°’∑’≠’°’ø’´’õ÷Ä ’∂’∏÷Ç’µ’∂’´’Ω’Ø ’¥’°’Ω’∂’°’Ø’´ ’≠’°÷É’°’∂’∏÷Ç’¥’∂’•÷Ä’´ ’§’•’∫÷Ñ’∏÷Ç’¥
3. **Retry with Backoff** ‚Äî ’Ø÷Ä’Ø’∂’´’õ÷Ä ’≠’•’¨’°÷Å’´, DDoS ’¥’´ ’°÷Ä’°
4. **Circuit Breaker** ‚Äî ’∫’°’∑’ø’∫’°’∂’´’õ÷Ä ’Ø’°’Ω’Ø’°’§’°’µ’´’∂ ’≠’°÷É’°’∂’∏÷Ç’¥’∂’•÷Ä’´÷Å

---

## ‚è±Ô∏è TIMEOUTS

### Timeout-’∂’•÷Ä’´ ’Ø’°’∂’∏’∂’∂’•÷Ä

```typescript
// ‚úÖ ’Ñ‘ª’á’è ’§’´÷Ä timeout-’•÷Ä ’°÷Ä’ø’°÷Ñ’´’∂ ’Ø’°’∂’π’•÷Ä’´ ’æ÷Ä’°

// HTTP ’∞’°÷Ä÷Å’∏÷Ç’¥’∂’•÷Ä
const controller = new AbortController();
const timeout = setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetch(url, {
    signal: controller.signal,
  });
} finally {
  clearTimeout(timeout);
}

// ‘ø’°’¥ ’£÷Ä’°’§’°÷Ä’°’∂’∏’æ
import ky from 'ky';

const api = ky.create({
  timeout: 10000, // 10 ’æ’°’µ÷Ä’Ø’µ’°’∂
  retry: {
    limit: 2,
    methods: ['get'],
    statusCodes: [408, 502, 503, 504],
  },
});
```

### ‘Ω’∏÷Ä’∞’∏÷Ç÷Ä’§ ’ø÷Ä’æ’∏’≤ timeout-’•÷Ä

| ‘≥’∏÷Ä’Æ’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂ | Timeout | ’Ü’∑’∏÷Ç’¥ |
|----------|---------|------------|
| API call (’∂’•÷Ä÷Ñ’´’∂) | 5-10s | ’ç’•÷É’°’Ø’°’∂ ’Ω’•÷Ä’æ’´’Ω’∂’•÷Ä’´ ’¥’´’ª÷á |
| API call (’°÷Ä’ø’°÷Ñ’´’∂) | 10-30s | ‘µ÷Ä÷Ä’∏÷Ä’§ ’Ø’∏’≤’¥’´ ’Ω’•÷Ä’æ’´’Ω’∂’•÷Ä |
| Database query | 5-30s | ‘ø’°’≠’æ’°’Æ ’¢’°÷Ä’§’∏÷Ç’©’µ’∏÷Ç’∂’´÷Å |
| File upload | 60-300s | ‘ø’°’≠’æ’°’Æ ’π’°÷É’´÷Å |
| Payment processing | 30-60s | ‘ø÷Ä’´’ø’´’Ø, retry-’∏’æ |

### Timeout-’•÷Ä Prisma-’∏÷Ç’¥

```typescript
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Connection string-’∏÷Ç’¥
// ?connection_limit=10&connect_timeout=10&pool_timeout=10

// ‘ø’°’¥ ’Ø’∏’§’∏÷Ç’¥
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
});

// Transaction timeout
await prisma.$transaction(
  async (tx) => {
    // operations
  },
  {
    maxWait: 5000,  // ’ç’∫’°’Ω’•’¨ transaction-’´’∂
    timeout: 10000, // ‘ª’∂÷Ñ’® transaction-’´ timeout
  }
);
```

---

## üîÑ RETRY STRATEGIES

### Exponential Backoff

```typescript
// lib/utils/retry.ts

interface RetryConfig {
  maxRetries: number;
  baseDelay: number;    // ms
  maxDelay: number;     // ms
  backoffFactor: number;
  jitter: boolean;
  retryCondition?: (error: Error) => boolean;
}

const DEFAULT_CONFIG: RetryConfig = {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 30000,
  backoffFactor: 2,
  jitter: true,
};

export async function withRetry<T>(
  fn: () => Promise<T>,
  config: Partial<RetryConfig> = {}
): Promise<T> {
  const {
    maxRetries,
    baseDelay,
    maxDelay,
    backoffFactor,
    jitter,
    retryCondition,
  } = { ...DEFAULT_CONFIG, ...config };

  let lastError: Error;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      // ’ç’ø’∏÷Ç’£’∏÷Ç’¥’ù retry ’°’∂’•’¨’∏÷Ç need ’Ø’°’û
      if (retryCondition && !retryCondition(lastError)) {
        throw lastError;
      }

      // ’é’•÷Ä’ª’´’∂ ÷É’∏÷Ä’± ‚Äî ’∂’•’ø’∏÷Ç’¥ ’•’∂÷Ñ ’Ω’≠’°’¨’®
      if (attempt === maxRetries) {
        throw lastError;
      }

      // ’Ä’°’∑’æ’∏÷Ç’¥ ’•’∂÷Ñ delay
      let delay = Math.min(
        baseDelay * Math.pow(backoffFactor, attempt),
        maxDelay
      );

      // ‘±’æ’•’¨’°÷Å’∂’∏÷Ç’¥ ’•’∂÷Ñ jitter (¬±10%)
      if (jitter) {
        const jitterAmount = delay * 0.1;
        delay += Math.random() * jitterAmount * 2 - jitterAmount;
      }

      console.log(
        `Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms`
      );

      await sleep(delay);
    }
  }

  throw lastError!;
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
```

### ’ï’£’ø’°’£’∏÷Ä’Æ’∏÷Ç’¥

```typescript
// ’ä’°÷Ä’¶ retry
const data = await withRetry(() => fetchData(url));

// Custom ’Ø’∏’∂÷Ü’´’£’∏’æ
const data = await withRetry(
  () => processPayment(orderId),
  {
    maxRetries: 5,
    baseDelay: 2000,
    retryCondition: (error) => {
      // Retry ’¥’´’°’µ’∂ ’∏÷Ä’∏’∑’°’Ø’´ ’Ω’≠’°’¨’∂’•÷Ä’´ ’∞’°’¥’°÷Ä
      if (error instanceof ApiError) {
        return error.statusCode >= 500 || error.statusCode === 429;
      }
      return true;
    },
  }
);
```

### ‘µ÷Ä’¢ retry ’â’°’∂’•’¨

```typescript
// ‚ùå Retry ’â’°’∂’•’¨.
// - 4xx ’Ω’≠’°’¨’∂’•÷Ä (’¢’°÷Å’´ 429, 408)
// - Validation errors
// - Auth errors (401, 403)
// - Business logic errors

const retryableStatuses = new Set([408, 429, 500, 502, 503, 504]);

const shouldRetry = (error: ApiError): boolean => {
  return retryableStatuses.has(error.statusCode);
};
```

---

## üîå CIRCUIT BREAKER

### Circuit Breaker ’∫’°’©’•’º’∂

```typescript
// lib/utils/circuit-breaker.ts

enum CircuitState {
  CLOSED = 'CLOSED',   // ’Ü’∏÷Ä’¥’°’¨ ’°’∑’≠’°’ø’°’∂÷Ñ
  OPEN = 'OPEN',       // ‘ø’°’∂’π’•÷Ä’® ’°÷Ä’£’•’¨’°÷É’°’Ø’∏÷Ç’¥ ’•’∂÷Ñ
  HALF_OPEN = 'HALF_OPEN', // ’ì’∏÷Ä’±’∏÷Ç’¥ ’•’∂÷Ñ ’æ’•÷Ä’°’Ø’°’∂’£’∂’æ’•’¨
}

interface CircuitBreakerConfig {
  failureThreshold: number;  // ’î’°’∂’´ ’Ω’≠’°’¨ ’¥’´’∂’π÷á ’¢’°÷Å’•’¨’®
  successThreshold: number;  // ’î’°’∂’´ ’∞’°’ª’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂ ÷É’°’Ø’•’¨’∏÷Ç ’∞’°’¥’°÷Ä
  timeout: number;           // OPEN ’æ’´’≥’°’Ø’∏÷Ç’¥ ’™’°’¥’°’∂’°’Ø (ms)
}

export class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failures: number = 0;
  private successes: number = 0;
  private lastFailureTime?: number;

  constructor(
    private readonly name: string,
    private readonly config: CircuitBreakerConfig = {
      failureThreshold: 5,
      successThreshold: 2,
      timeout: 30000,
    }
  ) {}

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    // ’ç’ø’∏÷Ç’£’∏÷Ç’¥ ’•’∂÷Ñ ’æ’´’≥’°’Ø’®
    if (this.state === CircuitState.OPEN) {
      if (this.shouldAttemptReset()) {
        this.state = CircuitState.HALF_OPEN;
      } else {
        throw new CircuitOpenError(this.name);
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failures = 0;

    if (this.state === CircuitState.HALF_OPEN) {
      this.successes++;
      if (this.successes >= this.config.successThreshold) {
        this.state = CircuitState.CLOSED;
        this.successes = 0;
        console.log(`Circuit ${this.name} CLOSED`);
      }
    }
  }

  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();

    if (this.state === CircuitState.HALF_OPEN) {
      this.state = CircuitState.OPEN;
      this.successes = 0;
      console.log(`Circuit ${this.name} OPEN (from HALF_OPEN)`);
    } else if (this.failures >= this.config.failureThreshold) {
      this.state = CircuitState.OPEN;
      console.log(`Circuit ${this.name} OPEN`);
    }
  }

  private shouldAttemptReset(): boolean {
    return (
      this.lastFailureTime !== undefined &&
      Date.now() - this.lastFailureTime >= this.config.timeout
    );
  }

  getState(): CircuitState {
    return this.state;
  }
}

class CircuitOpenError extends Error {
  constructor(circuitName: string) {
    super(`Circuit breaker "${circuitName}" is OPEN`);
    this.name = 'CircuitOpenError';
  }
}
```

### ’ï’£’ø’°’£’∏÷Ä’Æ’∏÷Ç’¥

```typescript
// Circuit breaker ’µ’∏÷Ç÷Ä’°÷Ñ’°’∂’π’µ’∏÷Ç÷Ä ’°÷Ä’ø’°÷Ñ’´’∂ ’Ω’•÷Ä’æ’´’Ω’´ ’∞’°’¥’°÷Ä
const paymentCircuit = new CircuitBreaker('payment-service', {
  failureThreshold: 3,
  successThreshold: 2,
  timeout: 60000,
});

async function processPayment(orderId: string) {
  return paymentCircuit.execute(async () => {
    return await paymentApi.charge(orderId);
  });
}

// ‘≤’°÷Å circuit-’´ ’§’•’∫÷Ñ’∏÷Ç’¥ ‚Äî graceful degradation
try {
  await processPayment(orderId);
} catch (error) {
  if (error instanceof CircuitOpenError) {
    // ‘±’µ’¨’®’∂’ø÷Ä’°’∂÷Ñ’°’µ’´’∂ ’≥’°’∂’°’∫’°÷Ä’∞
    await queuePaymentForLater(orderId);
    return { status: 'queued' };
  }
  throw error;
}
```

---

## üõë GRACEFUL SHUTDOWN

### Next.js ‚Äî cleanup –∏ health checks

```typescript
// Next.js Vercel-’∏÷Ç’¥ = serverless. Graceful shutdown ’∫’•’ø÷Ñ ’π’ß ‚Äî
// ’µ’∏÷Ç÷Ä’°÷Ñ’°’∂’π’µ’∏÷Ç÷Ä ’∞’°÷Ä÷Å’∏÷Ç’¥ ’¥’∑’°’Ø’æ’∏÷Ç’¥ ’ß ’¥’•’Ø’∏÷Ç’Ω’°÷Å’æ’°’Æ÷â

// Prisma-’´ ’∞’°’¥’°÷Ä Next.js-’∏÷Ç’¥ ‚Äî singleton ’∫’°’©’•’º’∂ cleanup-’∏’æ
// lib/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as { prisma: PrismaClient };

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

// Next.js health check (’°’∂’∞÷Ä’°’™’•’∑’ø ’ß external monitoring-’´ ’∞’°’¥’°÷Ä)
// app/api/health/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET() {
  try {
    await prisma.$queryRaw`SELECT 1`;
    return NextResponse.json({ status: 'ok', db: 'connected' });
  } catch {
    return NextResponse.json({ status: 'error', db: 'disconnected' }, { status: 503 });
  }
}
```

### NestJS ‚Äî Graceful Shutdown

```typescript
// main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Logger } from '@nestjs/common';

const SHUTDOWN_TIMEOUT_MS = 30_000;

async function bootstrap() {
  const logger = new Logger('Bootstrap');
  const app = await NestFactory.create(AppModule);
  const port = process.env.PORT || 3000;

  // ’Ñ’´’°÷Å’∂’∏÷Ç’¥ ’•’∂÷Ñ shutdown hooks
  app.enableShutdownHooks();

  // Graceful shutdown ’¥’∑’°’Ø’´’π
  const shutdown = async (signal: string) => {
    logger.log(`Received ${signal}. Starting graceful shutdown...`);

    const shutdownTimeout = setTimeout(() => {
      logger.error('Shutdown timeout exceeded, forcing exit');
      process.exit(1);
    }, SHUTDOWN_TIMEOUT_MS);

    try {
      await app.close();
      logger.log('Application closed successfully');
      clearTimeout(shutdownTimeout);
      process.exit(0);
    } catch (error) {
      logger.error('Error during shutdown', error);
      clearTimeout(shutdownTimeout);
      process.exit(1);
    }
  };

  // ‘º’Ω’∏÷Ç’¥ ’•’∂÷Ñ signal-’∂’•÷Ä’®
  process.on('SIGTERM', () => shutdown('SIGTERM'));
  process.on('SIGINT', () => shutdown('SIGINT'));

  await app.listen(port);
  logger.log(`Application started on port ${port}`);
}

bootstrap();
```

### NestJS ‚Äî OnModuleDestroy cleanup-’´ ’∞’°’¥’°÷Ä

```typescript
// services/database.service.ts
import { Injectable, OnModuleDestroy, Logger } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleDestroy {
  private readonly logger = new Logger(PrismaService.name);

  async onModuleDestroy() {
    this.logger.log('Disconnecting from database...');
    await this.$disconnect();
    this.logger.log('Database disconnected');
  }
}

// services/redis.service.ts
@Injectable()
export class RedisService implements OnModuleDestroy {
  private readonly logger = new Logger(RedisService.name);

  async onModuleDestroy() {
    this.logger.log('Closing Redis connection...');
    await this.redis.quit();
    this.logger.log('Redis disconnected');
  }
}
```

### NestJS ‚Äî Health Checks (Kubernetes Readiness/Liveness)

```typescript
// health/health.controller.ts
@Controller('health')
export class HealthController {
  constructor(private readonly health: HealthCheckService) {}

  // Liveness ‚Äî ’∞’°’æ’•’¨’æ’°’Æ’® ’Ø’•’∂’§’°’∂’´’û
  @Get('live')
  @HealthCheck()
  liveness() {
    return { status: 'ok' };
  }

  // Readiness ‚Äî ’∫’°’ø÷Ä’°’Ω’ø ’ß traffic ’®’∂’§’∏÷Ç’∂’•’¨’∏÷Ç’û
  @Get('ready')
  @HealthCheck()
  readiness() {
    return this.health.check([
      // ’ç’ø’∏÷Ç’£’∏÷Ç’¥ ’•’∂÷Ñ ‘≤‘¥-’®
      () => this.db.pingCheck('database'),
      // ’ç’ø’∏÷Ç’£’∏÷Ç’¥ ’•’∂÷Ñ Redis-’®
      () => this.redis.pingCheck('redis'),
    ]);
  }
}
```

---

## üî• FAULT TOLERANCE PATTERNS

### Fallback

```typescript
// ’ç’≠’°’¨’´ ’§’•’∫÷Ñ’∏÷Ç’¥ ‚Äî ÷Ö’£’ø’°’£’∏÷Ä’Æ’∏÷Ç’¥ ’•’∂÷Ñ fallback
async function getProductRecommendations(userId: string): Promise<Product[]> {
  try {
    return await recommendationService.getPersonalized(userId);
  } catch (error) {
    logger.warn('Recommendation service failed, using fallback', { userId });
    // Fallback ‚Äî ’∞’°’µ’ø’∂’´ ’°’∫÷Ä’°’∂÷Ñ’∂’•÷Ä
    return await productService.getPopular();
  }
}
```

### Bulkhead (’¥’•’Ø’∏÷Ç’Ω’°÷Å’∏÷Ç’¥)

```typescript
// ’Ñ’•’Ø’∏÷Ç’Ω’°÷Å’∂’∏÷Ç’¥ ’•’∂÷Ñ ’Ø÷Ä’´’ø’´’Ø’°’Ø’°’∂ ’£’∏÷Ä’Æ’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’®
import PQueue from 'p-queue';

// ‘±’º’°’∂’±’´’∂ ’∞’•÷Ä’©’•÷Ä ’ø’°÷Ä’¢’•÷Ä ’ø’´’∫’´ ’£’∏÷Ä’Æ’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’´ ’∞’°’¥’°÷Ä
const paymentQueue = new PQueue({ concurrency: 10 });
const emailQueue = new PQueue({ concurrency: 5 });
const analyticsQueue = new PQueue({ concurrency: 20 });

// ‘ø÷Ä’´’ø’´’Ø’°’Ø’°’∂ ’£’∏÷Ä’Æ’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’® ’π’•’∂ ’°÷Ä’£’•’¨’°÷É’°’Ø’æ’∏÷Ç’¥ ’∏’π-’Ø÷Ä’´’ø’´’Ø’°’Ø’°’∂’∂’•÷Ä’∏’æ
await paymentQueue.add(() => processPayment(order));
emailQueue.add(() => sendConfirmationEmail(order));  // ’ç’∫’°’Ω’∏÷Ç’¥ ’π’•’∂÷Ñ
analyticsQueue.add(() => trackPurchase(order));      // ’ç’∫’°’Ω’∏÷Ç’¥ ’π’•’∂÷Ñ
```

### Rate Limiting (Client Side)

```typescript
import Bottleneck from 'bottleneck';

// ’ç’°’∞’¥’°’∂’°÷É’°’Ø’∏÷Ç’¥ ’•’∂÷Ñ ’∞’°÷Ä÷Å’∏÷Ç’¥’∂’•÷Ä’® ’°÷Ä’ø’°÷Ñ’´’∂ API-’´’∂
const limiter = new Bottleneck({
  maxConcurrent: 5,      // ‘±’º’°’æ’•’¨’°’£’∏÷Ç’µ’∂’® 5 ’¥’´’°’™’°’¥’°’∂’°’Ø
  minTime: 100,          // ’Ü’æ’°’¶’°’£’∏÷Ç’µ’∂ 100ms ’∞’°÷Ä÷Å’∏÷Ç’¥’∂’•÷Ä’´ ’¥’´’ª÷á
  reservoir: 100,        // 100 ’∞’°÷Ä÷Å’∏÷Ç’¥
  reservoirRefreshAmount: 100,
  reservoirRefreshInterval: 60 * 1000, // ‘π’°÷Ä’¥’°÷Å’∂’•’¨ ’°’¥’•’∂ ÷Ä’∏’∫’•
});

const response = await limiter.schedule(() => 
  externalApi.call(data)
);
```

---

## üìã CHECKLIST

### Timeout-’•÷Ä

- [ ] ‘≤’∏’¨’∏÷Ä ’°÷Ä’ø’°÷Ñ’´’∂ ’Ø’°’∂’π’•÷Ä’∂ ’∏÷Ç’∂’•’∂ timeout
- [ ] Database query-’∂’•÷Ä timeout-’∏’æ
- [ ] HTTP request-’∂’•÷Ä timeout-’∏’æ
- [ ] Timeout-’•÷Ä’® ’∞’°’¥’°’∫’°’ø’°’Ω’≠’°’∂’∏÷Ç’¥ ’•’∂ ’£’∏÷Ä’Æ’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’´’∂

### Retry-’∂’•÷Ä

- [ ] Exponential backoff retry-’∂’•÷Ä’´ ’∞’°’¥’°÷Ä
- [ ] Jitter thundering herd-’® ’Ø’°’∂’≠’•’¨’∏÷Ç ’∞’°’¥’°÷Ä
- [ ] Retry ’¥’´’°’µ’∂ recoverable ’Ω’≠’°’¨’∂’•÷Ä’´ ’∞’°’¥’°÷Ä
- [ ] ’ç’°’∞’¥’°’∂ retry-’∂’•÷Ä’´ ÷Ñ’°’∂’°’Ø’´ ’æ÷Ä’°

### Graceful Shutdown

- [ ] SIGTERM/SIGINT-’´ ’¥’∑’°’Ø’∏÷Ç’¥
- [ ] Database connection-’∂’•÷Ä’´ ÷É’°’Ø’∏÷Ç’¥
- [ ] ‘±’Ø’ø’´’æ request-’∂’•÷Ä’´ ’°’æ’°÷Ä’ø’∏÷Ç’¥
- [ ] Timeout shutdown-’´ ’æ÷Ä’°

### Fault Tolerance

- [ ] Circuit breaker-’∂’•÷Ä ’°÷Ä’ø’°÷Ñ’´’∂ ’Ω’•÷Ä’æ’´’Ω’∂’•÷Ä’´ ’∞’°’¥’°÷Ä
- [ ] Fallback-’∂’•÷Ä non-critical ÷Ü’´’π’•÷Ä’´ ’∞’°’¥’°÷Ä
- [ ] Health check-’•÷Ä (liveness/readiness)
- [ ] Rate limiting ’∫’°’∑’ø’∫’°’∂’∏÷Ç’©’µ’°’∂ ’∞’°’¥’°÷Ä

---

**’è’°÷Ä’¢’•÷Ä’°’Ø.** 1.1
**‘±’¥’Ω’°’©’´’æ.** 2026-02-12
