---
description: Backend Ö‡ NestJS-Õ« Õ¯Õ¡Õ¶Õ¸Õ¶Õ¶Õ¥Ö€Ö‰ Ô¿Õ«Ö€Õ¡Õ¼Õ¾Õ¸Ö‚Õ´ Õ§ Õ½Õ¥Ö€Õ¾Õ¥Ö€Õ¡ÕµÕ«Õ¶ Õ¯Õ¸Õ¤Õ«Õ¶ Ö‡ API-Õ«Õ¶Ö‰
globs: ["**/api/**", "**/server/**", "**/backend/**", "**/*.service.ts", "**/*.controller.ts", "**/*.module.ts"]
alwaysApply: false
---

# BACKEND ÔµÕ NESTJS-Ô» Ô¿Ô±Õ†ÕˆÕ†Õ†ÔµÕ

> Õ„Õ¡Ö„Õ¸Ö‚Ö€ Õ³Õ¡Ö€Õ¿Õ¡Ö€Õ¡ÕºÕ¥Õ¿Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶, Õ¢Õ¡Ö€Õ¡Õ¯ Õ¯Õ¸Õ¶Õ¿Ö€Õ¸Õ¬Õ¥Ö€Õ¶Õ¥Ö€, Õ°Õ¡Õ½Õ¿ Õ½Õ¥Ö€Õ¾Õ«Õ½Õ¶Õ¥Ö€Ö‰

---

## ğŸ¯ Õ€Ô»Õ„Õ†Ô±Ô¿Ô±Õ† ÕÔ¿Ô¶Ô²ÕˆÕ’Õ†Õ”Õ†ÔµÕ

1. **Ô¿Õ¸Õ¶Õ¿Ö€Õ¸Õ¬Õ¥Ö€Õ¶Õ¥Ö€Õ¨ Õ¢Õ¡Ö€Õ¡Õ¯** â€” Õ´Õ«Õ¡ÕµÕ¶ Õ¼Õ¸Ö‚Õ¿Õ«Õ¶Õ£ Ö‡ Õ¾Õ¡Õ¬Õ«Õ¤Õ¡ÖÕ«Õ¡
2. **ÕÕ¥Ö€Õ¾Õ«Õ½Õ¶Õ¥Ö€Õ¸Ö‚Õ´ Õ§ Õ¬Õ¸Õ£Õ«Õ¯Õ¡Õ¶** â€” Õ¡Õ´Õ¢Õ¸Õ²Õ» Õ¢Õ«Õ¦Õ¶Õ¥Õ½-Õ¬Õ¸Õ£Õ«Õ¯Õ¡Õ¶ Õ¡ÕµÕ½Õ¿Õ¥Õ²
3. **Dependency Injection** â€” Õ¡Õ´Õ¥Õ¶ Õ«Õ¶Õ¹ Õ¯Õ¸Õ¶Õ½Õ¿Ö€Õ¸Ö‚Õ¯Õ¿Õ¸Ö€Õ« Õ´Õ«Õ»Õ¸ÖÕ¸Õ¾
4. **DTO Õ¢Õ¸Õ¬Õ¸Ö€ Õ¿Õ¾ÕµÕ¡Õ¬Õ¶Õ¥Ö€Õ« Õ°Õ¡Õ´Õ¡Ö€** â€” Õ¾Õ¡Õ¬Õ«Õ¤Õ¡ÖÕ«Õ¡ Õ´Õ¸Ö‚Õ¿Ö„Õ« Õ¯Õ¥Õ¿Õ¸Ö‚Õ´

---

## ğŸ“ Õ„ÕˆÔ´ÕˆÕ’Ô¼Ô» Ô¿Ô±ÕŒÕˆÕ’Õ‘ÕÔ±Ô¾Õ”

### NestJS Õ´Õ¸Õ¤Õ¸Ö‚Õ¬Õ« Õ½Õ¿Õ¡Õ¶Õ¤Õ¡Ö€Õ¿ Õ¯Õ¡Õ¼Õ¸Ö‚ÖÕ¾Õ¡Õ®Ö„

```
src/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â””â”€â”€ products.controller.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ products.service.ts
â”‚   â”‚   â”‚   â””â”€â”€ products-search.service.ts
â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”œâ”€â”€ create-product.dto.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ update-product.dto.ts
â”‚   â”‚   â”‚   â””â”€â”€ product-query.dto.ts
â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â””â”€â”€ product.entity.ts
â”‚   â”‚   â”œâ”€â”€ interfaces/
â”‚   â”‚   â”‚   â””â”€â”€ product.interface.ts
â”‚   â”‚   â”œâ”€â”€ products.module.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ orders/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚
â”‚   â””â”€â”€ auth/
â”‚       â””â”€â”€ ...
â”‚
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ decorators/
â”‚   â”œâ”€â”€ guards/
â”‚   â”œâ”€â”€ interceptors/
â”‚   â”œâ”€â”€ filters/
â”‚   â”œâ”€â”€ pipes/
â”‚   â””â”€â”€ utils/
â”‚
â”œâ”€â”€ config/
â”‚   â””â”€â”€ configuration.ts
â”‚
â””â”€â”€ main.ts
```

---

## ğŸ® Ô¿ÕˆÕ†ÕÕÕˆÔ¼ÔµÕÕ†ÔµÕ

### Ô²Õ¡Ö€Õ¡Õ¯ Õ¯Õ¸Õ¶Õ¿Ö€Õ¸Õ¬Õ¥Ö€ (Õ³Õ«Õ·Õ¿)

```typescript
// âœ… ÕƒÔ»Õ‡Õ â€” Õ¯Õ¸Õ¶Õ¿Ö€Õ¸Õ¬Õ¥Ö€ Õ´Õ«Õ¡ÕµÕ¶ Õ¼Õ¸Ö‚Õ¿Õ«Õ¶Õ£Õ« Õ°Õ¡Õ´Õ¡Ö€
@Controller('products')
@ApiTags('products')
export class ProductsController {
  constructor(private readonly productsService: ProductsService) {}

  @Get()
  @ApiOperation({ summary: 'ÕÕ¿Õ¡Õ¶Õ¡Õ¬ Õ¡ÕºÖ€Õ¡Õ¶Ö„Õ¶Õ¥Ö€Õ« ÖÕ¡Õ¶Õ¯' })
  async findAll(
    @Query() query: ProductQueryDto
  ): Promise<PaginatedResponse<Product>> {
    return this.productsService.findAll(query);
  }

  @Get(':id')
  @ApiOperation({ summary: 'ÕÕ¿Õ¡Õ¶Õ¡Õ¬ Õ¡ÕºÖ€Õ¡Õ¶Ö„ ID-Õ¸Õ¾' })
  async findOne(
    @Param('id', ParseUUIDPipe) id: string
  ): Promise<Product> {
    return this.productsService.findOne(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin')
  @ApiOperation({ summary: 'ÕÕ¿Õ¥Õ²Õ®Õ¥Õ¬ Õ¡ÕºÖ€Õ¡Õ¶Ö„' })
  async create(
    @Body() dto: CreateProductDto,
    @CurrentUser() user: User
  ): Promise<Product> {
    return this.productsService.create(dto, user);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin')
  async update(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() dto: UpdateProductDto
  ): Promise<Product> {
    return this.productsService.update(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin')
  @HttpCode(HttpStatus.NO_CONTENT)
  async remove(
    @Param('id', ParseUUIDPipe) id: string
  ): Promise<void> {
    await this.productsService.remove(id);
  }
}
```

### Õ€Õ¡Õ½Õ¿ Õ¯Õ¸Õ¶Õ¿Ö€Õ¸Õ¬Õ¥Ö€ (Õ½Õ­Õ¡Õ¬)

```typescript
// âŒ ÕÔ½Ô±Ô¼ â€” Õ¬Õ¸Õ£Õ«Õ¯Õ¡ Õ¯Õ¸Õ¶Õ¿Ö€Õ¸Õ¬Õ¥Ö€Õ¸Ö‚Õ´
@Controller('products')
export class ProductsController {
  constructor(private readonly prisma: PrismaService) {}

  @Get()
  async findAll(@Query() query: any) {
    // âŒ ÕˆÖ‚Õ²Õ²Õ¡Õ¯Õ« Ô²Ô´-Õ« Õ´Õ¸Ö‚Õ¿Ö„
    const products = await this.prisma.product.findMany({
      where: {
        isActive: true,
        category: query.category,
      },
      // âŒ ÕŠÕ¡Õ£Õ«Õ¶Õ¡ÖÕ«Õ¡ÕµÕ« Õ¬Õ¸Õ£Õ«Õ¯Õ¡ Õ¯Õ¸Õ¶Õ¿Ö€Õ¸Õ¬Õ¥Ö€Õ¸Ö‚Õ´
      skip: (query.page - 1) * query.limit,
      take: query.limit,
    });
    
    // âŒ ÕÕ¾ÕµÕ¡Õ¬Õ¶Õ¥Ö€Õ« Õ¿Ö€Õ¡Õ¶Õ½Ö†Õ¸Ö€Õ´Õ¡ÖÕ«Õ¡ Õ¯Õ¸Õ¶Õ¿Ö€Õ¸Õ¬Õ¥Ö€Õ¸Ö‚Õ´
    return products.map(p => ({
      ...p,
      priceFormatted: `${p.price} â‚½`,
    }));
  }
}
```

---

## âš™ï¸ ÕÔµÕÕÔ»ÕÕ†ÔµÕ

### ÕÕ¥Ö€Õ¾Õ«Õ½Õ« Õ¯Õ¡Õ¼Õ¸Ö‚ÖÕ¾Õ¡Õ®Ö„

```typescript
@Injectable()
export class ProductsService {
  private readonly logger = new Logger(ProductsService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly cacheService: CacheService,
    private readonly searchService: SearchService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  // Õ€Ö€Õ¡ÕºÕ¡Ö€Õ¡Õ¯Õ¡ÕµÕ«Õ¶ Õ´Õ¥Õ©Õ¸Õ¤Õ¶Õ¥Ö€ â€” Õ¢Õ«Õ¦Õ¶Õ¥Õ½-Ö…ÕºÕ¥Ö€Õ¡ÖÕ«Õ¡Õ¶Õ¥Ö€
  async findAll(query: ProductQueryDto): Promise<PaginatedResponse<Product>> {
    const { page = 1, limit = 20, category, search } = query;
    
    const where = this.buildWhereClause(query);
    
    const [items, total] = await Promise.all([
      this.prisma.product.findMany({
        where,
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { createdAt: 'desc' },
      }),
      this.prisma.product.count({ where }),
    ]);

    return {
      items,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findOne(id: string): Promise<Product> {
    // Õ†Õ¡Õ­ Õ½Õ¿Õ¸Ö‚Õ£Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ cache-Õ¨
    const cached = await this.cacheService.get<Product>(`product:${id}`);
    if (cached) return cached;

    const product = await this.prisma.product.findUnique({
      where: { id },
      include: { category: true, variants: true },
    });

    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }

    // Cache-Õ¸Ö‚Õ´
    await this.cacheService.set(`product:${id}`, product, 3600);

    return product;
  }

  async create(dto: CreateProductDto, user: User): Promise<Product> {
    // Ô²Õ«Õ¦Õ¶Õ¥Õ½-Õ¯Õ¡Õ¶Õ¸Õ¶Õ¶Õ¥Ö€Õ« Õ¾Õ¡Õ¬Õ«Õ¤Õ¡ÖÕ«Õ¡
    await this.validateCategory(dto.categoryId);
    
    const product = await this.prisma.product.create({
      data: {
        ...dto,
        createdBy: user.id,
      },
    });

    // Ô»Õ¶Õ¤Õ¥Ö„Õ½Õ¡ÖÕ«Õ¡ Õ¸Ö€Õ¸Õ¶Õ´Õ¡Õ¶ Õ°Õ¡Õ´Õ¡Ö€
    await this.searchService.index('products', product);
    
    // Ô»Õ¾Õ¥Õ¶Õ¿
    this.eventEmitter.emit('product.created', { product, user });
    
    this.logger.log(`Product created: ${product.id} by user ${user.id}`);

    return product;
  }

  async update(id: string, dto: UpdateProductDto): Promise<Product> {
    await this.findOne(id); // ÕÕ¿Õ¸Ö‚Õ£Õ¸Ö‚Õ´ Õ¥Õ¶Ö„, Õ¸Ö€ Õ£Õ¸ÕµÕ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶ Õ¸Ö‚Õ¶Õ«
    
    const product = await this.prisma.product.update({
      where: { id },
      data: dto,
    });

    // Cache-Õ« invalidation
    await this.cacheService.del(`product:${id}`);
    
    // Ô¹Õ¡Ö€Õ´Õ¡ÖÕ¶Õ¸Ö‚Õ´ Õ¥Õ¶Ö„ Õ«Õ¶Õ¤Õ¥Ö„Õ½Õ¨
    await this.searchService.update('products', product);
    
    this.eventEmitter.emit('product.updated', { product });

    return product;
  }

  async remove(id: string): Promise<void> {
    await this.findOne(id);
    
    await this.prisma.product.delete({ where: { id } });
    
    await this.cacheService.del(`product:${id}`);
    await this.searchService.remove('products', id);
    
    this.eventEmitter.emit('product.deleted', { id });
  }

  // Private Õ´Õ¥Õ©Õ¸Õ¤Õ¶Õ¥Ö€ â€” Ö…ÕªÕ¡Õ¶Õ¤Õ¡Õ¯ Õ¬Õ¸Õ£Õ«Õ¯Õ¡
  private buildWhereClause(query: ProductQueryDto): Prisma.ProductWhereInput {
    const where: Prisma.ProductWhereInput = {
      isActive: true,
    };

    if (query.category) {
      where.categoryId = query.category;
    }

    if (query.search) {
      where.OR = [
        { name: { contains: query.search, mode: 'insensitive' } },
        { description: { contains: query.search, mode: 'insensitive' } },
      ];
    }

    if (query.minPrice !== undefined || query.maxPrice !== undefined) {
      where.price = {};
      if (query.minPrice !== undefined) where.price.gte = query.minPrice;
      if (query.maxPrice !== undefined) where.price.lte = query.maxPrice;
    }

    return where;
  }

  private async validateCategory(categoryId: string): Promise<void> {
    const category = await this.prisma.category.findUnique({
      where: { id: categoryId },
    });
    
    if (!category) {
      throw new BadRequestException(`Category ${categoryId} not found`);
    }
  }
}
```

---

## ğŸ“ DTO (Data Transfer Objects)

### DTO-Õ« Õ¯Õ¡Õ¶Õ¸Õ¶Õ¶Õ¥Ö€

```typescript
// dto/create-product.dto.ts
import { IsString, IsNumber, IsOptional, IsUUID, Min, MaxLength } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateProductDto {
  @ApiProperty({ description: 'Ô±ÕºÖ€Õ¡Õ¶Ö„Õ« Õ¡Õ¶Õ¸Ö‚Õ¶', example: 'iPhone 15' })
  @IsString()
  @MaxLength(255)
  name: string;

  @ApiPropertyOptional({ description: 'Õ†Õ¯Õ¡Ö€Õ¡Õ£Ö€Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶', example: 'Õ†Õ¸Ö€ iPhone...' })
  @IsOptional()
  @IsString()
  @MaxLength(5000)
  description?: string;

  @ApiProperty({ description: 'Ô³Õ«Õ¶ Õ¯Õ¸ÕºÕ¥Õ¯Õ¶Õ¥Ö€Õ¸Õ¾', example: 99900 })
  @IsNumber()
  @Min(0)
  price: number;

  @ApiProperty({ description: 'Ô¿Õ¡Õ¿Õ¥Õ£Õ¸Ö€Õ«Õ¡ÕµÕ« ID' })
  @IsUUID()
  categoryId: string;

  @ApiPropertyOptional({ description: 'SKU', example: 'IPHONE-15-128' })
  @IsOptional()
  @IsString()
  @MaxLength(50)
  sku?: string;
}

// dto/update-product.dto.ts
import { PartialType } from '@nestjs/swagger';

export class UpdateProductDto extends PartialType(CreateProductDto) {}

// dto/product-query.dto.ts
export class ProductQueryDto {
  @ApiPropertyOptional({ default: 1 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @ApiPropertyOptional({ default: 20, maximum: 100 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  limit?: number = 20;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsUUID()
  category?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(0)
  minPrice?: number;

  @ApiPropertyOptional()
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(0)
  maxPrice?: number;
}
```

---

## ğŸ›¡ï¸ GUARDS ÔµÕ MIDDLEWARE

### Auth Guard

```typescript
// common/guards/jwt-auth.guard.ts
@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    return super.canActivate(context);
  }

  handleRequest<TUser = User>(err: any, user: TUser): TUser {
    if (err || !user) {
      throw new UnauthorizedException('Invalid or expired token');
    }
    return user;
  }
}

// common/guards/roles.guard.ts
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>('roles', [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) return true;

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    return requiredRoles.some(role => user.roles?.includes(role));
  }
}
```

### Ô¿Õ¡Õ½Õ¿Õ¸Õ´ Õ¤Õ¥Õ¯Õ¸Ö€Õ¡Õ¿Õ¸Ö€Õ¶Õ¥Ö€

```typescript
// common/decorators/current-user.decorator.ts
export const CurrentUser = createParamDecorator(
  (data: keyof User | undefined, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;
    return data ? user?.[data] : user;
  },
);

// common/decorators/roles.decorator.ts
export const Roles = (...roles: string[]) => SetMetadata('roles', roles);

// Õ•Õ£Õ¿Õ¡Õ£Õ¸Ö€Õ®Õ¸Ö‚Õ´
@Get('profile')
@UseGuards(JwtAuthGuard)
getProfile(@CurrentUser() user: User) {
  return user;
}

@Post()
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('admin')
create(@Body() dto: CreateDto) { ... }
```

---

## âš ï¸ ÕÔ½Ô±Ô¼Õ†ÔµÕÔ» Õ„Õ‡Ô±Ô¿ÕˆÕ’Õ„

### Exception Filter

```typescript
// common/filters/http-exception.filter.ts
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const { status, message, errors } = this.getErrorDetails(exception);

    const errorResponse = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message,
      ...(errors && { errors }),
    };

    this.logger.error(
      `${request.method} ${request.url} - ${status}`,
      exception instanceof Error ? exception.stack : undefined,
    );

    response.status(status).json(errorResponse);
  }

  private getErrorDetails(exception: unknown) {
    if (exception instanceof HttpException) {
      const response = exception.getResponse();
      return {
        status: exception.getStatus(),
        message: typeof response === 'string' 
          ? response 
          : (response as any).message,
        errors: (response as any).errors,
      };
    }

    if (exception instanceof Prisma.PrismaClientKnownRequestError) {
      return this.handlePrismaError(exception);
    }

    return {
      status: HttpStatus.INTERNAL_SERVER_ERROR,
      message: 'Internal server error',
    };
  }

  private handlePrismaError(error: Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002':
        return { status: 409, message: 'Resource already exists' };
      case 'P2025':
        return { status: 404, message: 'Resource not found' };
      default:
        return { status: 500, message: 'Database error' };
    }
  }
}
```

### Ô²Õ«Õ¦Õ¶Õ¥Õ½ Exceptions

```typescript
// common/exceptions/business.exception.ts
export class BusinessException extends HttpException {
  constructor(
    message: string,
    public readonly code: string,
    statusCode: number = HttpStatus.BAD_REQUEST,
  ) {
    super({ message, code }, statusCode);
  }
}

export class InsufficientStockException extends BusinessException {
  constructor(productId: string, requested: number, available: number) {
    super(
      `Insufficient stock for product ${productId}. Requested: ${requested}, Available: ${available}`,
      'INSUFFICIENT_STOCK',
    );
  }
}

// Õ•Õ£Õ¿Õ¡Õ£Õ¸Ö€Õ®Õ¸Ö‚Õ´
if (variant.stock < quantity) {
  throw new InsufficientStockException(productId, quantity, variant.stock);
}
```

---

## ğŸ“Š Ô¼ÕˆÔ³Ô±ÕÕˆÕÕˆÕ’Õ„

```typescript
// Õ•Õ£Õ¿Õ¡Õ£Õ¸Ö€Õ®Õ«Õ›Ö€ Õ¶Õ¥Ö€Õ¯Õ¡Õ¼Õ¸Ö‚ÖÕ¾Õ¡Õ® Logger
@Injectable()
export class OrdersService {
  private readonly logger = new Logger(OrdersService.name);

  async create(dto: CreateOrderDto): Promise<Order> {
    this.logger.log(`Creating order for user ${dto.userId}`);
    
    try {
      const order = await this.processOrder(dto);
      this.logger.log(`Order created: ${order.id}`);
      return order;
    } catch (error) {
      this.logger.error(`Failed to create order: ${error.message}`, error.stack);
      throw error;
    }
  }
}
```

---

## ğŸ“‹ CHECKLIST

### Õ„Õ¸Õ¤Õ¸Ö‚Õ¬

- [ ] Ô¿Õ¸Õ¶Õ¿Ö€Õ¸Õ¬Õ¥Ö€Õ¨ Õ¢Õ¡Ö€Õ¡Õ¯ (Õ´Õ«Õ¡ÕµÕ¶ Õ¼Õ¸Ö‚Õ¿Õ«Õ¶Õ£)
- [ ] ÕÕ¥Ö€Õ¾Õ«Õ½Õ¨ ÕºÕ¡Ö€Õ¸Ö‚Õ¶Õ¡Õ¯Õ¸Ö‚Õ´ Õ§ Õ¢Õ«Õ¦Õ¶Õ¥Õ½-Õ¬Õ¸Õ£Õ«Õ¯Õ¡
- [ ] DTO Õ¾Õ¡Õ¬Õ«Õ¤Õ¡ÖÕ«Õ¡ÕµÕ¸Õ¾
- [ ] Swagger ÖƒÕ¡Õ½Õ¿Õ¡Õ©Õ²Õ©Õ¡Õ¾Õ¸Ö€Õ¸Ö‚Õ´
- [ ] Guards Õ§Õ¶Õ¤ÕºÕ¸ÕµÕ¶Õ¿Õ¶Õ¥Ö€Õ« ÕºÕ¡Õ·Õ¿ÕºÕ¡Õ¶Õ¸Ö‚Õ©ÕµÕ¡Õ¶ Õ°Õ¡Õ´Õ¡Ö€
- [ ] ÕÕ­Õ¡Õ¬Õ¶Õ¥Ö€Õ« Õ´Õ·Õ¡Õ¯Õ¸Ö‚Õ´
- [ ] Ô¿Õ¡Ö€Ö‡Õ¸Ö€ Ö…ÕºÕ¥Ö€Õ¡ÖÕ«Õ¡Õ¶Õ¥Ö€Õ« Õ¬Õ¸Õ£Õ¡Õ¾Õ¸Ö€Õ¸Ö‚Õ´

---

**ÕÕ¡Ö€Õ¢Õ¥Ö€Õ¡Õ¯.** 1.0
**Ô±Õ´Õ½Õ¡Õ©Õ«Õ¾.** 2026-02-12
